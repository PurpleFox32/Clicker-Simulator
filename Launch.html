<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clicking Simulator</title>
    <style>
        :root {
            --bg: #121212;
            --fg: #fff;
            --panel: #1e1e1e;
            --accent: #4caf50;
            --muted: #333;
            --border: #ffffff88;
            --disabled: #888;
            --red: #e74c3c;
            --green: #2ecc71;
            --blue: #3498db;
        }

        * {
            box-sizing: border-box;
        }

        body {
            display: flex;
            align-items: stretch;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif;
        }

        /* ===== Dev panel (left) ===== */
        .dev-panel {
            position: sticky;
            top: 0;
            width: 320px;
            min-width: 320px;
            max-height: 100dvh;
            overflow: auto;
            background: #0e0e0e;
            border-right: 1px solid #222;
            padding: 14px;
        }

        .dev-title {
            font-weight: 700;
            margin-bottom: 8px;
        }

        .dev-sec {
            border: 1px solid #222;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 10px;
            background: #141414;
        }

        .dev-sec h4 {
            margin: 0 0 8px 0;
            font-size: 14px;
            opacity: .9;
        }

        .dev-row {
            display: grid;
            grid-template-columns: 1fr 130px;
            gap: 8px;
            align-items: center;
            margin-bottom: 6px;
        }

        .dev-row label {
            font-size: 12px;
            opacity: .9;
        }

        .dev-row input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #2a2a2a;
            background: #1a1a1a;
            color: #ddd;
        }

        .dev-row input[type="checkbox"] {
            transform: scale(1.1);
            justify-self: start;
        }

        .dev-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .dev-btn {
            padding: 8px 10px;
            font-size: 12px;
            border-radius: 8px;
            border: 1px solid #333;
            background: #1b1b1b;
            color: #eee;
            cursor: pointer;
        }

        .dev-btn:active {
            transform: translateY(1px);
        }

        .dev-note {
            font-size: 12px;
            opacity: .7;
            margin-top: 6px;
        }

        /* ===== Main column ===== */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 24px;
            gap: 16px;
        }

        button {
            padding: 20px 40px;
            font-size: 24px;
            background: var(--panel);
            color: var(--fg);
            border: 1px solid var(--border);
            cursor: pointer;
            border-radius: 8px;
            transition: transform .03s ease;
        }

        button:active {
            transform: translateY(1px) scale(0.99);
        }

        button[disabled] {
            opacity: .6;
            cursor: not-allowed;
            border-color: #444;
            color: var(--disabled);
        }

        .progress-container {
            width: min(900px, 90vw);
            background: var(--muted);
            height: 30px;
            border-radius: 6px;
            overflow: hidden;
            margin: 10px 0;
            border: 1px solid #000;
        }

        .progress-bar {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width .1s linear;
        }

        .stats {
            font-size: 18px;
            text-align: center;
        }

        .upgrades {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .upgrade-button,
        #resetButton,
        #rebirth {
            padding: 12px 16px;
            font-size: 16px;
            border-radius: 8px;
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
        }

        .small {
            opacity: .85;
            font-size: 14px;
        }

        .sep {
            opacity: .35;
            margin: 0 8px;
        }

        /* Bottom-right stacked panels (Clicks on top, Points under it) */
        .corner-stack {
            position: fixed;
            right: 16px;
            bottom: 16px;
            display: grid;
            gap: 10px;
            z-index: 10;
        }

        .corner-panel {
            width: 300px;
            background: #0f0f0f;
            border: 1px solid #222;
            border-radius: 12px;
            padding: 10px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.45);
            display: grid;
            gap: 8px;
            font-size: 13px;
        }

        .corner-title {
            font-size: 14px;
            opacity: .85;
            text-align: center;
            margin-bottom: 2px;
        }

        .tier {
            background: #151515;
            border: 1px solid #232323;
            border-radius: 10px;
            padding: 8px;
            display: grid;
            gap: 6px;
            position: relative;
            min-height: 82px;
            overflow: hidden;
        }

        .tier-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
        }

        .tier-name {
            font-weight: 600;
        }

        .meter {
            height: 8px;
            background: #2a2a2a;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #111;
        }

        .meter>.fill {
            height: 100%;
            width: 0%;
            transition: width .08s linear;
        }

        .fill.red {
            background: var(--red);
        }

        .fill.green {
            background: var(--green);
        }

        .fill.blue {
            background: var(--blue);
        }

        .tiny-btn {
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
            background: #1a1a1a;
            color: #ddd;
            cursor: pointer;
        }

        .tiny-btn[disabled] {
            opacity: .55;
            cursor: not-allowed;
        }

        /* Locked overlay button fills the tier until unlocked */
        .locked-view {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(1px);
        }

        .locked-view>button,
        .lock-msg {
            width: 92%;
            height: 70%;
            font-size: 16px;
            border-radius: 10px;
            border: 1px solid #3a3a3a;
            background: #161616;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 6px 10px;
        }

        .unlocked-view {
            display: none;
        }

        .tier.unlocked .locked-view {
            display: none;
        }

        .tier.unlocked .unlocked-view {
            display: grid;
            gap: 6px;
        }

        /* Small right-aligned time labels under the bar */
        .time-row {
            display: flex;
            justify-content: flex-end;
            font-size: 11px;
            opacity: .8;
            margin-top: -2px;
        }
    </style>
</head>

<body>

    <!-- ===== Dev Panel (LEFT) ===== -->
    <aside class="dev-panel">
        <div class="dev-title">Dev Panel</div>

        <div class="dev-sec">
            <h4>Global</h4>
            <div class="dev-row"><label for="devPoints">Points</label><input type="number" id="devPoints" min="0"
                    step="1"></div>
            <div class="dev-row"><label for="devRebirths">Rebirths</label><input type="number" id="devRebirths" min="0"
                    step="1"></div>
            <div class="dev-row"><label for="devClickLvl">Click Upgrade L</label><input type="number" id="devClickLvl"
                    min="1" step="1"></div>
            <div class="dev-row"><label for="devPointLvl">Point Upgrade L</label><input type="number" id="devPointLvl"
                    min="1" step="1"></div>
            <div class="dev-row"><label for="devProgress">Progress</label><input type="number" id="devProgress" min="0"
                    step="1"></div>
            <div class="dev-row"><label for="devProgressMax">Progress Max</label><input type="number"
                    id="devProgressMax" min="1" step="1"></div>
            <div class="dev-row"><label for="devClickPower">Base Click Power</label><input type="number"
                    id="devClickPower" min="1" step="1"></div>
            <div class="dev-row"><label for="devPointReward">Base Point Reward</label><input type="number"
                    id="devPointReward" min="1" step="1"></div>
            <div class="dev-actions">
                <button class="dev-btn" id="devApplyGlobal">Apply</button>
                <button class="dev-btn" id="devRefreshGlobal">Refresh</button>
            </div>
        </div>

        <div class="dev-sec">
            <h4>Click Tiers</h4>
            <div id="devClickTiers"></div>
        </div>

        <div class="dev-sec">
            <h4>Point Tiers</h4>
            <div id="devPointTiers"></div>
        </div>

        <div class="dev-sec">
            <h4>Storage</h4>
            <div class="dev-actions">
                <button class="dev-btn" id="devSave">Save</button>
                <button class="dev-btn" id="devLoad">Load</button>
                <button class="dev-btn" id="devReset">Full Reset</button>
            </div>
            <div class="dev-note">Edits take effect immediately; Save writes to localStorage.</div>
        </div>
    </aside>

    <!-- ===== Main Game Column ===== -->
    <main class="main">
        <div class="stats" id="totalClicks">Total Clicks: 0</div>

        <button id="clickButton" title="Click (Space/Enter)">Click Me!</button>

        <div class="progress-container">
            <div class="progress-bar" id="progressBar"></div>
        </div>

        <div class="stats" id="scoreDisplay">
            Points: 0 | Clicks Needed: 10 | Clicks Remaining: 10
        </div>

        <div class="row small" id="metaDisplay">
            Rebirths: 0<span class="sep">•</span>
            Click Power: 1<span class="sep">•</span>
            Point Reward: 1
        </div>

        <div class="upgrades">
            <button class="upgrade-button" id="upgradePoints" title="Increase points gained per fill">Upgrade Points L1
                (Cost: 10)</button>
            <button class="upgrade-button" id="upgradeClicks" title="Increase progress per click">Upgrade Click Power L1
                (Cost: 20)</button>
            <button id="rebirth" title="Reset for permanent multiplier">Rebirth (Cost: 1000)</button>
            <button id="resetButton" title="Clear save and reload">Reset Game</button>
        </div>
    </main>

    <!-- Bottom-right: Click panel on top, Points panel under it -->
    <div class="corner-stack">
        <!-- Auto Clicks -->
        <div class="corner-panel" id="clickPanel">
            <div class="corner-title">Auto Click Tiers</div>

            <!-- Tier 1 -->
            <div class="tier" data-tier="0" id="tier0">
                <div class="locked-view"><button id="t0Unlock">Unlock Tier 1 (20)</button></div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 1</div>
                        <div class="tier-stats" id="t0Stats">+1 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill red" id="t0Fill"></div>
                    </div>
                    <div class="time-row"><span id="t0TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <button class="tiny-btn" id="t0Time">Time L0 (20)</button>
                        <button class="tiny-btn" id="t0Power">Power L0 (20)</button>
                    </div>
                </div>
            </div>

            <!-- Tier 2 -->
            <div class="tier" data-tier="1" id="tier1">
                <div class="locked-view"><button id="t1Unlock">Unlock Tier 2 (40)</button></div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 2</div>
                        <div class="tier-stats" id="t1Stats">+2 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill green" id="t1Fill"></div>
                    </div>
                    <div class="time-row"><span id="t1TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <button class="tiny-btn" id="t1Time">Time L0 (40)</button>
                        <button class="tiny-btn" id="t1Power">Power L0 (40)</button>
                    </div>
                </div>
            </div>

            <!-- Tier 3 -->
            <div class="tier" data-tier="2" id="tier2">
                <div class="locked-view"><button id="t2Unlock">Unlock Tier 3 (60)</button></div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 3</div>
                        <div class="tier-stats" id="t2Stats">+3 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill blue" id="t2Fill"></div>
                    </div>
                    <div class="time-row"><span id="t2TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <button class="tiny-btn" id="t2Time">Time L0 (60)</button>
                        <button class="tiny-btn" id="t2Power">Power L0 (60)</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Auto Points -->
        <div class="corner-panel" id="pointPanel">
            <div class="corner-title">Auto Point Tiers</div>

            <!-- P Tier 1 -->
            <div class="tier" data-ptier="0" id="ptier0">
                <div class="locked-view">
                    <div class="lock-msg" id="p0LockMsg">Requires 1 rebirth</div>
                </div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 1</div>
                        <div class="tier-stats" id="p0Stats">+1 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill red" id="p0Fill"></div>
                    </div>
                    <div class="time-row"><span id="p0TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <span class="small" style="opacity:.7">Fixed 10s</span>
                        <button class="tiny-btn" id="p0Power">Power L0 (20)</button>
                    </div>
                </div>
            </div>

            <!-- P Tier 2 -->
            <div class="tier" data-ptier="1" id="ptier1">
                <div class="locked-view">
                    <div class="lock-msg" id="p1LockMsg">Requires 2 rebirths</div>
                </div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 2</div>
                        <div class="tier-stats" id="p1Stats">+2 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill green" id="p1Fill"></div>
                    </div>
                    <div class="time-row"><span id="p1TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <span class="small" style="opacity:.7">Fixed 10s</span>
                        <button class="tiny-btn" id="p1Power">Power L0 (40)</button>
                    </div>
                </div>
            </div>

            <!-- P Tier 3 -->
            <div class="tier" data-ptier="2" id="ptier2">
                <div class="locked-view">
                    <div class="lock-msg" id="p2LockMsg">Requires 3 rebirths</div>
                </div>
                <div class="unlocked-view">
                    <div class="tier-row">
                        <div class="tier-name">Tier 3</div>
                        <div class="tier-stats" id="p2Stats">+3 / 10s</div>
                    </div>
                    <div class="meter">
                        <div class="fill blue" id="p2Fill"></div>
                    </div>
                    <div class="time-row"><span id="p2TimeLabel">10.00s</span></div>
                    <div class="tier-row">
                        <span class="small" style="opacity:.7">Fixed 10s</span>
                        <button class="tiny-btn" id="p2Power">Power L0 (60)</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ======= Config / Defaults =======
        const SAVE_KEY = 'clickerSave_v5';
        const fmt = (n) => {
            if (n >= 1_000_000_000) return (n / 1_000_000_000).toFixed(2) + 'B';
            if (n >= 1_000_000) return (n / 1_000_000).toFixed(2) + 'M';
            if (n >= 10_000) return Math.floor(n).toLocaleString();
            return Math.ceil(n).toString();
        };

        const BASE = Object.freeze({
            progressMax: 10,
            clickPower: 1,
            pointReward: 1,
            pointUpgradeCost: 10,
            clickUpgradeCost: 20,
            rebirthCost: 1000,

            // Balance (unchanged)
            pointUpgradeCostMultiplier: 1.35,
            clickUpgradeCostMultiplier: 1.50,
            progressGrowthPerFill: 1.015,

            clickDelayMs: 0,

            // Auto Click tiers
            clickTierDefs: [
                { color: 'red', unlockCost: 20, basePower: 1 },
                { color: 'green', unlockCost: 40, basePower: 2 },
                { color: 'blue', unlockCost: 60, basePower: 3 },
            ],
            timeStepMs: 250,
            timeMaxLevel: 36,
            timeStartMs: 10000,
            timeMinMs: 1000,
            powerMaxExtraClicks: 20,
            tierUpgradeCostMult: 1.5,

            // Auto Point tiers
            pointTierDefs: [
                { color: 'red', basePower: 1, unlockRebirths: 1, baseCost: 20 },
                { color: 'green', basePower: 2, unlockRebirths: 2, baseCost: 40 },
                { color: 'blue', basePower: 3, unlockRebirths: 3, baseCost: 60 },
            ],
            pointFixedIntervalMs: 10000,
            pointPowerStep: 2,
            powerMaxLevelsPoints: 20,
        });

        // ======= State =======
        let state = {
            version: 5,
            progressMax: BASE.progressMax,
            points: 0,
            clicks: 0,
            clickPower: BASE.clickPower,
            pointReward: BASE.pointReward,
            rebirthMultiplier: 1,
            clickUpgradeLevel: 1,
            pointUpgradeLevel: 1,
            rebirths: 0,
            pointUpgradeCost: BASE.pointUpgradeCost,
            clickUpgradeCost: BASE.clickUpgradeCost,
            rebirthCost: BASE.rebirthCost,
            progress: 0,
            lastSave: Date.now(),
            clickTiers: BASE.clickTierDefs.map((def) => ({
                color: def.color,
                unlocked: false,
                basePower: def.basePower,
                powerLevel: 0,
                timeLevel: 0,
                elapsedMs: 0,
                timeCost: def.unlockCost,
                powerCost: def.unlockCost,
                unlockCost: def.unlockCost
            })),
            pointTiers: BASE.pointTierDefs.map((def) => ({
                color: def.color,
                // NEW: dev override flag for unlocking
                devForceUnlocked: false,
                unlocked: false, // computed from (devForceUnlocked || rebirths)
                basePower: def.basePower,
                powerLevel: 0,
                elapsedMs: 0,
                powerCost: def.baseCost,
                unlockRebirths: def.unlockRebirths,
                baseCost: def.baseCost
            }))
        };

        // ======= DOM =======
        const el = {
            progressBar: document.getElementById('progressBar'),
            clickButton: document.getElementById('clickButton'),
            scoreDisplay: document.getElementById('scoreDisplay'),
            totalClicksDisplay: document.getElementById('totalClicks'),
            upgradePoints: document.getElementById('upgradePoints'),
            upgradeClicks: document.getElementById('upgradeClicks'),
            rebirth: document.getElementById('rebirth'),
            resetButton: document.getElementById('resetButton'),
            metaDisplay: document.getElementById('metaDisplay'),

            // Click tiers UI refs
            ctier: [
                { root: tier0, stats: t0Stats, fill: t0Fill, btnUnlock: t0Unlock, btnTime: t0Time, btnPower: t0Power, timeLabel: t0TimeLabel },
                { root: tier1, stats: t1Stats, fill: t1Fill, btnUnlock: t1Unlock, btnTime: t1Time, btnPower: t1Power, timeLabel: t1TimeLabel },
                { root: tier2, stats: t2Stats, fill: t2Fill, btnUnlock: t2Unlock, btnTime: t2Time, btnPower: t2Power, timeLabel: t2TimeLabel },
            ],

            // Point tiers UI refs
            ptier: [
                { root: ptier0, stats: p0Stats, fill: p0Fill, timeLabel: p0TimeLabel, btnPower: p0Power, lockMsg: p0LockMsg },
                { root: ptier1, stats: p1Stats, fill: p1Fill, timeLabel: p1TimeLabel, btnPower: p1Power, lockMsg: p1LockMsg },
                { root: ptier2, stats: p2Stats, fill: p2Fill, timeLabel: p2TimeLabel, btnPower: p2Power, lockMsg: p2LockMsg },
            ]
        };

        // ======= Core helpers =======
        const incrementPerClick = () => Math.max(1, Math.ceil(state.rebirthMultiplier * state.clickPower * state.clickUpgradeLevel));

        function dynamicPointsMultiplier() {
            return Math.max(1, Math.pow(state.progressMax / BASE.progressMax, 0.5));
        }
        const pointsPerFill = () =>
            Math.max(1, Math.ceil(state.rebirthMultiplier * state.pointReward * state.pointUpgradeLevel * dynamicPointsMultiplier()));

        function clicksRemainingToFill() {
            const inc = incrementPerClick();
            return Math.max(1, Math.ceil((state.progressMax - state.progress) / inc));
        }

        function applyProgress(amount) {
            state.progress += amount;
            while (state.progress >= state.progressMax) {
                state.progress -= state.progressMax;
                state.points += pointsPerFill();
                state.progressMax = Math.ceil(state.progressMax * BASE.progressGrowthPerFill);
            }
        }

        function handleClickCore(countUserClick = true) {
            if (countUserClick) state.clicks++;
            applyProgress(incrementPerClick());
            updateDisplays();
        }

        // ======= Auto systems =======
        function doAutoClicks(power) {
            for (let i = 0; i < power; i++) handleClickCore(false);
        }
        function addPointsDirect(amount) {
            state.points += amount;
            updateDisplays();
        }

        // Click tiers helpers
        function clickIntervalMs(t) {
            const base = BASE.timeStartMs - t.timeLevel * BASE.timeStepMs;
            return Math.max(BASE.timeMinMs, base);
        }
        function clickTierPower(t) { return t.basePower + Math.min(BASE.powerMaxExtraClicks, t.powerLevel); }
        function updateClickTierUI(i) {
            const t = state.clickTiers[i];
            const ui = el.ctier[i];

            ui.root.classList.toggle('unlocked', !!t.unlocked);
            ui.btnUnlock.textContent = `Unlock Tier ${i + 1} (${fmt(t.unlockCost)})`;
            ui.btnUnlock.disabled = !!t.unlocked || state.points < t.unlockCost;

            if (!t.unlocked) {
                ui.fill.style.width = '0%';
                ui.timeLabel.textContent = `${(clickIntervalMs(t) / 1000).toFixed(2)}s`;
                return;
            }

            const secs = clickIntervalMs(t) / 1000;
            ui.stats.textContent = `+${clickTierPower(t)} / ${secs.toFixed(secs % 1 === 0 ? 0 : 2)}s`;

            const remain = Math.max(0, (clickIntervalMs(t) - t.elapsedMs) / 1000);
            ui.timeLabel.textContent = `${remain.toFixed(remain % 1 === 0 ? 0 : 2)}s`;

            const timeMaxed = t.timeLevel >= BASE.timeMaxLevel || clickIntervalMs(t) <= BASE.timeMinMs;
            ui.btnTime.textContent = timeMaxed ? `Time L${t.timeLevel} (MAX)` : `Time L${t.timeLevel} (${fmt(Math.ceil(t.timeCost))})`;
            ui.btnTime.disabled = timeMaxed || state.points < Math.ceil(t.timeCost);

            const powerMaxed = t.powerLevel >= BASE.powerMaxExtraClicks;
            ui.btnPower.textContent = powerMaxed ? `Power L${t.powerLevel} (MAX)` : `Power L${t.powerLevel} (${fmt(Math.ceil(t.powerCost))})`;
            ui.btnPower.disabled = powerMaxed || state.points < Math.ceil(t.powerCost);
        }

        // Point tiers helpers — respect dev override
        function pointIntervalMs() { return BASE.pointFixedIntervalMs; }
        function pointTierPower(t) { return t.basePower + (t.powerLevel * BASE.pointPowerStep); }
        function isPointTierUnlocked(t) {
            return !!t.devForceUnlocked || state.rebirths >= t.unlockRebirths;
        }
        function updatePointTierUI(i) {
            const t = state.pointTiers[i];
            const ui = el.ptier[i];

            t.unlocked = isPointTierUnlocked(t);
            ui.root.classList.toggle('unlocked', t.unlocked);

            if (!t.unlocked) {
                ui.lockMsg.textContent = `Requires ${t.unlockRebirths} rebirth${t.unlockRebirths === 1 ? '' : 's'} (or enable in Dev)`;
                ui.fill.style.width = '0%';
                ui.timeLabel.textContent = `${(pointIntervalMs() / 1000).toFixed(2)}s`;
                return;
            }

            const secs = pointIntervalMs() / 1000;
            ui.stats.textContent = `+${pointTierPower(t)} / ${secs.toFixed(0)}s`;

            const remain = Math.max(0, (pointIntervalMs() - t.elapsedMs) / 1000);
            ui.timeLabel.textContent = `${remain.toFixed(remain % 1 === 0 ? 0 : 2)}s`;

            const powerMaxed = t.powerLevel >= BASE.powerMaxLevelsPoints;
            ui.btnPower.textContent = powerMaxed ? `Power L${t.powerLevel} (MAX)` : `Power L${t.powerLevel} (${fmt(Math.ceil(t.powerCost))})`;
            ui.btnPower.disabled = powerMaxed || state.points < Math.ceil(t.powerCost);
        }

        function updateButtons() {
            const canPoints = state.points >= Math.ceil(state.pointUpgradeCost);
            const canClicks = state.points >= Math.ceil(state.clickUpgradeCost);
            const canRebirth = state.points >= Math.ceil(state.rebirthCost);

            el.upgradePoints.disabled = !canPoints;
            el.upgradeClicks.disabled = !canClicks;
            el.rebirth.disabled = !canRebirth;

            el.upgradePoints.textContent = `Upgrade Points L${state.pointUpgradeLevel} (Cost: ${fmt(state.pointUpgradeCost)})`;
            el.upgradeClicks.textContent = `Upgrade Click Power L${state.clickUpgradeLevel} (Cost: ${fmt(state.clickUpgradeCost)})`;
            el.rebirth.textContent = `Rebirth (Cost: ${fmt(state.rebirthCost)})`;

            for (let i = 0; i < state.clickTiers.length; i++) updateClickTierUI(i);
            for (let i = 0; i < state.pointTiers.length; i++) updatePointTierUI(i);
        }

        function updateDisplays() {
            const clicksRemain = clicksRemainingToFill();
            el.scoreDisplay.textContent = `Points: ${fmt(state.points)} | Clicks Needed: ${fmt(clicksRemain)} | Clicks Remaining: ${fmt(clicksRemain)}`;
            el.totalClicksDisplay.textContent = `Total Clicks: ${fmt(state.clicks)}`;
            el.metaDisplay.innerHTML =
                `Rebirths: ${state.rebirths}<span class="sep">•</span>` +
                `Click Power: ${fmt(state.clickPower)}<span class="sep">•</span>` +
                `Point Reward: ${fmt(state.pointReward)}`;
            el.progressBar.style.width = `${(state.progress / state.progressMax) * 100}%`;
            updateButtons();
            saveGame();
        }

        // ===== Events =====
        clickButton.addEventListener('click', () => {
            if (BASE.clickDelayMs > 0) setTimeout(() => handleClickCore(true), BASE.clickDelayMs);
            else handleClickCore(true);
        });
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.code === 'Enter') {
                e.preventDefault();
                clickButton.click();
            }
        });

        upgradePoints.addEventListener('click', () => {
            const cost = Math.ceil(state.pointUpgradeCost);
            if (state.points >= cost) {
                state.points -= cost; state.pointUpgradeLevel++; state.pointUpgradeCost *= BASE.pointUpgradeCostMultiplier;
                if (state.points < 0) state.points = 0; updateDisplays();
            }
        });
        upgradeClicks.addEventListener('click', () => {
            const cost = Math.ceil(state.clickUpgradeCost);
            if (state.points >= cost) {
                state.points -= cost; state.clickUpgradeLevel++; state.clickUpgradeCost *= BASE.clickUpgradeCostMultiplier;
                if (state.points < 0) state.points = 0; updateDisplays();
            }
        });

        rebirth.addEventListener('click', () => {
            const cost = Math.ceil(state.rebirthCost);
            if (state.points < cost) return;
            if (!confirm(`Rebirth for ${fmt(cost)} points? Current x${state.rebirthMultiplier} → x${state.rebirthMultiplier + 1}`)) return;
            state.points -= cost; state.rebirths += 1; state.rebirthMultiplier += 1;
            state.clicks = 0; state.progress = 0; state.progressMax = BASE.progressMax;
            state.clickUpgradeLevel = 1; state.pointUpgradeLevel = 1;
            state.pointUpgradeCost = BASE.pointUpgradeCost; state.clickUpgradeCost = BASE.clickUpgradeCost;
            state.rebirthCost = Math.ceil(state.rebirthCost * 5);
            updateDisplays();
            alert(`Rebirth complete! Permanent multiplier is now x${state.rebirthMultiplier}.`);
        });

        resetButton.addEventListener('click', () => {
            if (confirm('Reset all progress and clear save?')) { localStorage.removeItem(SAVE_KEY); location.reload(); }
        });

        // ===== Wire Click Tiers =====
        function wireClickTier(i) {
            const t = state.clickTiers[i];
            const ui = el.ctier[i];

            ui.btnUnlock.addEventListener('click', () => {
                if (t.unlocked) return;
                if (state.points >= t.unlockCost) {
                    state.points -= t.unlockCost; t.unlocked = true; t.elapsedMs = 0;
                    ui.root.classList.add('unlocked'); updateDisplays();
                }
            });

            ui.btnTime.addEventListener('click', () => {
                if (!t.unlocked) return;
                const maxed = t.timeLevel >= BASE.timeMaxLevel;
                const cost = Math.ceil(t.timeCost);
                if (!maxed && state.points >= cost) {
                    state.points -= cost; t.timeLevel++; t.timeCost = Math.ceil(t.timeCost * BASE.tierUpgradeCostMult);
                    if (clickIntervalMs(t) <= BASE.timeMinMs) t.timeLevel = BASE.timeMaxLevel;
                    updateDisplays();
                }
            });

            ui.btnPower.addEventListener('click', () => {
                if (!t.unlocked) return;
                const maxed = t.powerLevel >= BASE.powerMaxExtraClicks;
                const cost = Math.ceil(t.powerCost);
                if (!maxed && state.points >= cost) {
                    state.points -= cost; t.powerLevel++; t.powerCost = Math.ceil(t.powerCost * BASE.tierUpgradeCostMult);
                    updateDisplays();
                }
            });
        }
        for (let i = 0; i < state.clickTiers.length; i++) wireClickTier(i);

        // ===== Wire Point Tiers (power only) =====
        function wirePointTier(i) {
            const t = state.pointTiers[i];
            const ui = el.ptier[i];
            ui.btnPower.addEventListener('click', () => {
                if (!isPointTierUnlocked(t)) return;
                const maxed = t.powerLevel >= BASE.powerMaxLevelsPoints;
                const cost = Math.ceil(t.powerCost);
                if (!maxed && state.points >= cost) {
                    state.points -= cost; t.powerLevel++; t.powerCost = Math.ceil(t.powerCost * BASE.tierUpgradeCostMult);
                    updateDisplays();
                }
            });
        }
        for (let i = 0; i < state.pointTiers.length; i++) wirePointTier(i);

        // ===== Save / Load =====
        function saveGame() {
            state.lastSave = Date.now();
            try { localStorage.setItem(SAVE_KEY, JSON.stringify(state)); } catch (e) { }
        }
        function loadGame() {
            try {
                const raw = localStorage.getItem(SAVE_KEY);
                if (!raw) return;
                const saved = JSON.parse(raw);
                if (!saved || saved.version !== 5) return;
                // Ensure new flag exists for older saves
                if (saved.pointTiers) {
                    saved.pointTiers.forEach(pt => { if (typeof pt.devForceUnlocked === 'undefined') pt.devForceUnlocked = false; });
                }
                state = { ...state, ...saved };
            } catch (e) { }
        }
        loadGame();

        function fullRefreshUI() { updateDisplays(); }
        fullRefreshUI();

        // ===== Main Tick Loop =====
        let lastTs = performance.now();
        function loop(ts) {
            const dt = ts - lastTs; lastTs = ts;

            // Click tiers
            for (let i = 0; i < state.clickTiers.length; i++) {
                const t = state.clickTiers[i], ui = el.ctier[i];
                if (!t.unlocked) {
                    ui.fill.style.width = '0%';
                    ui.timeLabel.textContent = `${(clickIntervalMs(t) / 1000).toFixed(2)}s`;
                    continue;
                }
                const interval = clickIntervalMs(t);
                t.elapsedMs += dt;
                const remain = Math.max(0, (interval - t.elapsedMs) / 1000);
                ui.timeLabel.textContent = `${remain.toFixed(remain % 1 === 0 ? 0 : 2)}s`;
                ui.fill.style.width = `${Math.min(1, t.elapsedMs / interval) * 100}%`;
                if (t.elapsedMs >= interval) { t.elapsedMs %= interval; doAutoClicks(clickTierPower(t)); }
            }

            // Point tiers (respect dev override)
            for (let i = 0; i < state.pointTiers.length; i++) {
                const t = state.pointTiers[i], ui = el.ptier[i];
                const wasUnlocked = t.unlocked;
                t.unlocked = isPointTierUnlocked(t);
                ui.root.classList.toggle('unlocked', t.unlocked);

                if (!t.unlocked) {
                    ui.fill.style.width = '0%';
                    ui.lockMsg.textContent = `Requires ${t.unlockRebirths} rebirth${t.unlockRebirths === 1 ? '' : 's'} (or enable in Dev)`;
                    ui.timeLabel.textContent = `${(pointIntervalMs() / 1000).toFixed(2)}s`;
                    continue;
                } else if (!wasUnlocked) {
                    t.elapsedMs = 0;
                }

                const interval = pointIntervalMs();
                t.elapsedMs += dt;
                const remain = Math.max(0, (interval - t.elapsedMs) / 1000);
                ui.timeLabel.textContent = `${remain.toFixed(remain % 1 === 0 ? 0 : 2)}s`;
                ui.fill.style.width = `${Math.min(1, t.elapsedMs / interval) * 100}%`;
                if (t.elapsedMs >= interval) { t.elapsedMs %= interval; addPointsDirect(pointTierPower(t)); }
            }

            updateButtons();
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        setInterval(saveGame, 5000);

        // ===== Dev Panel Logic =====
        const dev = {
            points: devPoints, rebirths: devRebirths, clickLvl: devClickLvl, pointLvl: devPointLvl,
            progress: devProgress, progressMax: devProgressMax, clickPower: devClickPower, pointReward: devPointReward,
            applyGlobal: devApplyGlobal, refreshGlobal: devRefreshGlobal,
            devClickTiers: document.getElementById('devClickTiers'),
            devPointTiers: document.getElementById('devPointTiers'),
            saveBtn: devSave, loadBtn: devLoad, resetBtn: devReset,
        };

        function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

        function refreshGlobalFields() {
            dev.points.value = state.points;
            dev.rebirths.value = state.rebirths;
            dev.clickLvl.value = state.clickUpgradeLevel;
            dev.pointLvl.value = state.pointUpgradeLevel;
            dev.progress.value = Math.floor(state.progress);
            dev.progressMax.value = state.progressMax;
            dev.clickPower.value = state.clickPower;
            dev.pointReward.value = state.pointReward;
        }
        function applyGlobalFields() {
            state.points = Math.max(0, Number(dev.points.value || 0));
            state.rebirths = Math.max(0, Math.floor(Number(dev.rebirths.value || 0)));
            state.clickUpgradeLevel = Math.max(1, Math.floor(Number(dev.clickLvl.value || 1)));
            state.pointUpgradeLevel = Math.max(1, Math.floor(Number(dev.pointLvl.value || 1)));
            state.progressMax = Math.max(1, Math.floor(Number(dev.progressMax.value || 1)));
            state.progress = clamp(Math.floor(Number(dev.progress.value || 0)), 0, state.progressMax - 1);
            state.clickPower = Math.max(1, Math.floor(Number(dev.clickPower.value || 1)));
            state.pointReward = Math.max(1, Math.floor(Number(dev.pointReward.value || 1)));
            updateDisplays();
        }
        dev.applyGlobal.addEventListener('click', applyGlobalFields);
        dev.refreshGlobal.addEventListener('click', refreshGlobalFields);

        // Click Tier editors
        function buildClickTierEditors() {
            dev.devClickTiers.innerHTML = '';
            state.clickTiers.forEach((t, i) => {
                const wrap = document.createElement('div');
                wrap.className = 'dev-sec';
                wrap.innerHTML = `
          <h4>Click Tier ${i + 1}</h4>
          <div class="dev-row"><label>Unlocked</label><input type="checkbox" id="dc_u_${i}"></div>
          <div class="dev-row"><label>Time Level (0-36)</label><input type="number" id="dc_t_${i}" min="0" max="${BASE.timeMaxLevel}" step="1"></div>
          <div class="dev-row"><label>Power Level (0-20)</label><input type="number" id="dc_p_${i}" min="0" max="${BASE.powerMaxExtraClicks}" step="1"></div>
          <div class="dev-actions">
            <button class="dev-btn" id="dc_apply_${i}">Apply</button>
            <button class="dev-btn" id="dc_refresh_${i}">Refresh</button>
            <button class="dev-btn" id="dc_resetTimer_${i}">Reset Timer</button>
          </div>
        `;
                dev.devClickTiers.appendChild(wrap);

                const cbUnlock = wrap.querySelector(`#dc_u_${i}`);
                const inTime = wrap.querySelector(`#dc_t_${i}`);
                const inPower = wrap.querySelector(`#dc_p_${i}`);
                wrap.querySelector(`#dc_apply_${i}`).addEventListener('click', () => {
                    state.clickTiers[i].unlocked = cbUnlock.checked;
                    state.clickTiers[i].timeLevel = clamp(Number(inTime.value || 0), 0, BASE.timeMaxLevel);
                    state.clickTiers[i].powerLevel = clamp(Number(inPower.value || 0), 0, BASE.powerMaxExtraClicks);
                    updateDisplays();
                });
                wrap.querySelector(`#dc_refresh_${i}`).addEventListener('click', () => {
                    cbUnlock.checked = !!state.clickTiers[i].unlocked;
                    inTime.value = state.clickTiers[i].timeLevel;
                    inPower.value = state.clickTiers[i].powerLevel;
                });
                wrap.querySelector(`#dc_resetTimer_${i}`).addEventListener('click', () => { state.clickTiers[i].elapsedMs = 0; });

                // initial
                cbUnlock.checked = !!state.clickTiers[i].unlocked;
                inTime.value = state.clickTiers[i].timeLevel;
                inPower.value = state.clickTiers[i].powerLevel;
            });
        }

        // Point Tier editors — checkbox controls devForceUnlocked
        function buildPointTierEditors() {
            dev.devPointTiers.innerHTML = '';
            state.pointTiers.forEach((t, i) => {
                const wrap = document.createElement('div');
                wrap.className = 'dev-sec';
                wrap.innerHTML = `
          <h4>Point Tier ${i + 1}</h4>
          <div class="dev-row"><label>Force Unlocked (dev)</label><input type="checkbox" id="dp_u_${i}"></div>
          <div class="dev-row"><label>Power Level (0-20)</label><input type="number" id="dp_p_${i}" min="0" max="${BASE.powerMaxLevelsPoints}" step="1"></div>
          <div class="dev-actions">
            <button class="dev-btn" id="dp_apply_${i}">Apply</button>
            <button class="dev-btn" id="dp_refresh_${i}">Refresh</button>
            <button class="dev-btn" id="dp_resetTimer_${i}">Reset Timer</button>
          </div>
        `;
                dev.devPointTiers.appendChild(wrap);

                const cbForce = wrap.querySelector(`#dp_u_${i}`);
                const inPower = wrap.querySelector(`#dp_p_${i}`);

                wrap.querySelector(`#dp_apply_${i}`).addEventListener('click', () => {
                    state.pointTiers[i].devForceUnlocked = !!cbForce.checked;
                    state.pointTiers[i].powerLevel = clamp(Number(inPower.value || 0), 0, BASE.powerMaxLevelsPoints);
                    updateDisplays();
                });
                wrap.querySelector(`#dp_refresh_${i}`).addEventListener('click', () => {
                    cbForce.checked = !!state.pointTiers[i].devForceUnlocked;
                    inPower.value = state.pointTiers[i].powerLevel;
                });
                wrap.querySelector(`#dp_resetTimer_${i}`).addEventListener('click', () => { state.pointTiers[i].elapsedMs = 0; });

                // initial
                cbForce.checked = !!state.pointTiers[i].devForceUnlocked;
                inPower.value = state.pointTiers[i].powerLevel;
            });
        }

        // Dev storage buttons
        dev.saveBtn.addEventListener('click', saveGame);
        dev.loadBtn.addEventListener('click', () => { loadGame(); updateDisplays(); refreshGlobalFields(); buildClickTierEditors(); buildPointTierEditors(); });
        dev.resetBtn.addEventListener('click', () => { if (confirm('Clear local save and reload?')) { localStorage.removeItem(SAVE_KEY); location.reload(); } });

        // initialize dev panel
        function initDev() { refreshGlobalFields(); buildClickTierEditors(); buildPointTierEditors(); }
        initDev();
    </script>
</body>

</html>